<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Data types and structures</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Data types and structures</h1>

<h3>Understanding basic data types in R</h3>

<p>To make the best of the R language you&#39;ll need:  </p>

<ol>
<li>a good understanding of the data types and data structures available in R</li>
<li>to know how to operate on those.</li>
</ol>

<p>Dealing with object conversions is commonly frustrating for beginners.
Mastering this knowledge will make your continued experience much more pleasant.</p>

<h3>Data structures</h3>

<p>R has many <strong>data structures</strong>. These include</p>

<ul>
<li>atomic vector</li>
<li>list</li>
<li>matrix</li>
<li>data frame</li>
<li>factors</li>
</ul>

<h3>Vectors</h3>

<p>A vector is the most common and basic data structure in R, and is pretty much the workhorse of R.</p>

<p>Technically, vectors can be one of two types:</p>

<ul>
<li>atomic vectors</li>
<li>lists</li>
</ul>

<p>although the term &ldquo;vector&rdquo; most commonly refers to the atomic types not lists.</p>

<p><strong>Atomic Vectors</strong></p>

<p>By <em>atomic</em>, we mean the vector only holds data of a single type.</p>

<ul>
<li><strong>character</strong>: <code>&quot;a&quot;</code>, <code>&quot;swc&quot;</code></li>
<li><strong>numeric</strong>: <code>2</code>, <code>15.5</code></li>
<li><strong>integer</strong>: <code>2L</code> (the <code>L</code> tells R to store this as an integer)</li>
<li><strong>logical</strong>: <code>TRUE</code>, <code>FALSE</code></li>
<li><strong>complex</strong>: <code>1+4i</code> (complex numbers with real and imaginary parts)</li>
</ul>

<p>You can create an empty vector with <code>vector()</code> 
By default the mode is <code>logical</code>. You can be more explicit as shown in the examples below. 
It is more common to use direct constructors such as <code>character()</code>, <code>numeric()</code>, etc. </p>

<pre><code class="r">x &lt;- vector()
# with a length and type
vector(&quot;character&quot;, length = 10)
character(5)  ## character vector of length 5
numeric(5)
logical(5)
</code></pre>

<h3>Creating vectors with values</h3>

<p><strong>Numeric vectors</strong></p>

<pre><code class="r">x &lt;- c(1, 2.5, 3)
x
length(x)
</code></pre>

<p><code>x</code> is now numeric vector, where each value is a double precision real number.</p>

<p><strong>Logical vector</strong></p>

<pre><code class="r">y &lt;- c(TRUE, TRUE, FALSE, FALSE)
</code></pre>

<p><strong>character vectors</strong></p>

<pre><code class="r">z &lt;- c(&quot;Sarah&quot;, &quot;Tracy&quot;, &quot;Jon&quot;)
</code></pre>

<p><strong>Examine your vectors</strong></p>

<p>R provides many functions to examine features of vectors and other objects, for example</p>

<ul>
<li><code>typeof()</code> - what is it?<br/></li>
<li><code>length()</code> - how long is it?<br/></li>
</ul>

<pre><code class="r"># Example
typeof(z)
length(z)
</code></pre>

<hr/>

<p>You can also create vectors by generating a sequence of numbers</p>

<pre><code class="r">series &lt;- 1:10
series
seq(10)
seq(1, 10, by = 0.1)
</code></pre>

<p>Atomic vectors are flat, and nesting c()s just creates a flat vector:</p>

<pre><code class="r">c(1, c(2, c(3, 4)))

# the same as
c(1, 2, 3, 4)
</code></pre>

<p><strong>Add an element to a vector</strong></p>

<pre><code class="r">z
z &lt;- c(z, &quot;Annette&quot;)
z
</code></pre>

<p><strong>Special values</strong></p>

<p><code>Inf</code> is infinity. You can have either positive or negative infinity.</p>

<pre><code class="r">1/0
</code></pre>

<p><code>NaN</code> means Not a Number. It&#39;s an undefined value.</p>

<pre><code class="r">0/0
</code></pre>

<p><strong>What happens when you mix types?</strong></p>

<p>R will create a resulting vector that is the least common denominator. The coercion will move towards the one that&#39;s easiest to <strong>coerce</strong> to.</p>

<h3>Challenge</h3>

<p>Guess what the following do without running them first</p>

<pre><code class="r">xx &lt;- c(1.7, &quot;a&quot;)
xx &lt;- c(TRUE, 2)
xx &lt;- c(&quot;a&quot;, TRUE)
</code></pre>

<p>This is called implicit coercion. You can also coerce vectors explicitly using the <code>as.&lt;class_name&gt;</code>. Example</p>

<pre><code class="r">as.numeric()
as.character()
</code></pre>

<h3>List</h3>

<p>Lists are different from atomic vectors in that they can contain any other type of vector, including lists. You construct them using list() instead of c(). Coerce an atomic vector to a list by <code>as.list()</code></p>

<pre><code class="r">x &lt;- list(1, &quot;a&quot;, TRUE, 1 + (0+4i))
str(x)
length(x)

x &lt;- 1:10
x &lt;- as.list(x)
length(x)
</code></pre>

<p>to get values out from a list:</p>

<pre><code class="r">x[1]  #gives back a new list, holding the corresponding value
x[[1]]  #gives back a value
</code></pre>

<p>Elements are indexed by double brackets. Single brackets will still return a(nother) list.</p>

<p>Generating a more complex list</p>

<pre><code class="r">xlist &lt;- list(a = &quot;Karthik Ram&quot;, b = 1:10, data = head(iris))
xlist
</code></pre>

<ol>
<li>What is the length of this object? What about its structure?</li>
</ol>

<p>Lists can be extremely useful inside functions.
You can “staple” together lots of different kinds of results into a single object that a function can return.</p>

<p>A list does not print to the console like a vector. Instead, each element of the list starts on a new line.</p>

<h3>Attributes</h3>

<p>All objects can have arbitrary additional attributes.
These can be thought of as a named list. 
Attributes can be accessed individually with attr() or all at once (as a list) with <code>attributes()</code>.</p>

<pre><code class="r">x &lt;- list(filename = &quot;myFile.txt&quot;, path = &quot;/tmp&quot;)
typeof(x)
attributes(x)

y &lt;- c(&quot;mySecondFile.txt&quot;, &quot;/tmp&quot;)
names(y) &lt;- c(&quot;otherFilename&quot;, &quot;/tmp&quot;)
attributes(y)
</code></pre>

<h3>Factors</h3>

<p>A factor is a vector that can contain only predefined values.
It is R&#39;s structure for dealing with qualitative data.</p>

<p>A factor is not an atomic vector, but it&#39;s built on top of an integer vector.</p>

<p>Factors have two key attributes: their class(), &ldquo;factor&rdquo;, which controls their behaviour;
and their levels(), the set of allowed values.</p>

<pre><code class="r">x &lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;yes&quot;))
x
class(x)
levels(x)
</code></pre>

<p>You can&#39;t use values that are not in the levels</p>

<pre><code class="r">x[2] &lt;- &quot;c&quot;
</code></pre>

<pre><code>## Warning: invalid factor level, NA generated
</code></pre>

<p>Factors look (and often behave) like character vectors, but are actually 
stored as integers, with labels associated the unique integers.</p>

<p>You need to be careful when treating them like strings.
Some string methods will coerce factors to strings, while others will throw an error.</p>

<pre><code class="r">paste(&quot;value:&quot;, x)
nchar(x)  #error
</code></pre>

<pre><code>## Error: &#39;nchar()&#39; requires a character vector
</code></pre>

<pre><code class="r">nchar(&quot;test&quot;)
</code></pre>

<p>For this reason, it&#39;s usually best to explicitly convert factors to strings when modifying their levels.
If you need to convert a factor to a character vector, simply use</p>

<pre><code class="r">as.character(x)
</code></pre>

<p>To convert a factor to a numeric vector, go via a character. Compare</p>

<pre><code class="r">f &lt;- factor(c(1, 5, 10, 2))
as.numeric(f)  ## wrong!
as.numeric(as.character(f))
</code></pre>

<p>Also, you can not combine factors</p>

<pre><code class="r">c(factor(&quot;a&quot;), factor(&quot;b&quot;))
</code></pre>

<p><strong>Ordering factors</strong></p>

<p>In modeling functions, it is important to know what the baseline level is. This is the first factor but by default the ordering is determined by alphabetical order of words entered. You can change this by speciying the levels.</p>

<pre><code class="r">x &lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;))
x
</code></pre>

<p>Factors are useful when you know the possible values a variable may take, 
even if you don&#39;t see all values in a given dataset.</p>

<p>Using a factor instead of a character vector makes it obvious when some groups contain no observations:</p>

<pre><code class="r">sex_char &lt;- c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;)
sex_factor &lt;- factor(sex_char, levels = c(&quot;m&quot;, &quot;f&quot;))

# `table(x)` returns a frequency table counting the number of elements in
# each level.

table(sex_char)

table(sex_factor)
</code></pre>

<h3>Factor gotchas</h3>

<p>Unfortunately, most data loading functions in R automatically convert character vectors to factors. The reason is (probably) that in early versions of R, there was a memory advantage to using factors; that is no longer the case.</p>

<p>Often, this is not what we want.</p>

<p>Instead, we can use the argument stringsAsFactors = FALSE to suppress this behaviour, and then manually convert character vectors to factors using our knowledge of the data.</p>

<pre><code class="r">read.delim(&quot;data/gapminderDataFiveYear.txt&quot;, stringsAsFactors = FALSE)
</code></pre>

<p>A global option (options(stringsAsFactors = FALSE) is available to control this behaviour
It&#39;s not recommended, because it makes it harder to share your code, and it may have unexpected consequences when combined with other code (either from packages, or code that you&#39;re source()ing).</p>

<p>Global options make code harder to understand, because they increase the number of lines you need to read to understand what a function is doing. </p>

<hr/>

<p>Atomic vectors and lists are the building blocks for higher dimensional data structures. Atomic vectors extend to matrices and arrays, and lists are used to create data frames.</p>

<h3>Matrix</h3>

<p>In R matrices are an extension of the numeric or character vectors. 
They are not a separate type of object but simply an atomic vector with dimensions; 
the number of rows and columns.</p>

<pre><code class="r">m &lt;- matrix(nrow = 2, ncol = 2)
m
dim(m)
</code></pre>

<p>Matrices in R are filled column-wise.</p>

<pre><code class="r">m &lt;- matrix(1:6, nrow = 2, ncol = 3)
m
</code></pre>

<p>Another way to construct a matrix is to bind columns or rows using <code>cbind()</code> and <code>rbind()</code>.</p>

<pre><code class="r">x &lt;- 1:3
y &lt;- 10:12
cbind(x, y)
rbind(x, y)
</code></pre>

<p>You can also use the byrow argument to specify how the matrix is filled. </p>

<p>Here I want to show you how you can run examlpes from R&#39;s own documentation:</p>

<pre><code class="r">`?`(matrix)
example(matrix)
mdat
# mdat &lt;- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
# dimnames = list(c(&#39;row1&#39;, &#39;row2&#39;), c(&#39;C.1&#39;, &#39;C.2&#39;, &#39;C.3&#39;)))
</code></pre>

<h3>Data frame</h3>

<p>A data frame is a very important data type in R. It&#39;s pretty much the de facto data structure for most tabular data and what we use for statistics.</p>

<p>A data frame is a special type of list where every element of the list has same length.</p>

<pre><code class="r">dat &lt;- data.frame(id = letters[1:10], x = 1:10, y = 11:20)
dat
</code></pre>

<p>Data frames can have additional attributes such as <code>rownames()</code>, which can be useful for annotating data, like subject_id or sample_id.</p>

<p>Some additional information on data frames:</p>

<ul>
<li>Usually created by <code>read.csv()</code> ,<code>read.table()</code> or <code>read.delim()</code>.</li>
<li>Can also create with <code>data.frame()</code> function.</li>
<li>Find the number of rows and columns with <code>nrow(dat)</code> and <code>ncol(dat)</code>, respectively.</li>
</ul>

<h3>Useful functions</h3>

<ul>
<li><code>head()</code> - see first 6 rows</li>
<li><code>tail()</code> - see last 6 rows</li>
<li><code>dim()</code> - see dimensions</li>
<li><code>nrow()</code> - number of rows</li>
<li><code>ncol()</code> - number of columns</li>
<li><code>str()</code> - structure of each column</li>
<li><code>names()</code> - will list the names attribute for a data frame (or any object really), which gives the column names.</li>
<li>A data frame is a special type of list where every element of the list has same length.</li>
</ul>

<pre><code class="r">str(iris)
nrow(iris)
ncol(iris)
head(iris)
tail(iris)
names(iris)
row.names(iris)
</code></pre>

<p>See that it is actually a special list:</p>

<pre><code class="r">is.list(iris)
class(iris)
</code></pre>

<p>OK, Let&#39;s get hands-on.</p>

</body>

</html>

